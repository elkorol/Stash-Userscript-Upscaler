import * as tf from '@tensorflow/tfjs-core';
export const isShape4D = (shape) => {
    if (!Boolean(shape) || !Array.isArray(shape) || shape.length !== 4) {
        return false;
    }
    for (const val of shape) {
        if (val !== null && typeof val !== 'number') {
            return false;
        }
    }
    return true;
};
export function makeIsNDimensionalTensor(rank) {
    function fn(pixels) {
        try {
            return pixels.shape.length === rank;
        }
        catch (err) { }
        return false;
    }
    return fn;
}
export const isFourDimensionalTensor = makeIsNDimensionalTensor(4);
export const isThreeDimensionalTensor = makeIsNDimensionalTensor(3);
export const isTensor = (input) => input instanceof tf.Tensor;
export const isString = (el) => typeof el === 'string';
export const isValidModelType = (modelType) => typeof modelType === 'string' && ['layers', 'graph',].includes(modelType);
export var MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE;
(function (MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE) {
    MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE["UNDEFINED"] = "undefined";
    MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE["INVALID_MODEL_TYPE"] = "invalidModelType";
    MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE["MISSING_PATH"] = "missingPath";
})(MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE || (MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE = {}));
export class ModelDefinitionValidationError extends Error {
    type;
    constructor(type) {
        super(type);
        this.type = type;
    }
}
export const isValidModelDefinition = (modelDefinition) => {
    if (modelDefinition === undefined) {
        throw new ModelDefinitionValidationError(MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE.UNDEFINED);
    }
    if (!isValidModelType(modelDefinition.modelType || 'layers')) {
        throw new ModelDefinitionValidationError(MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE.INVALID_MODEL_TYPE);
    }
    if (!modelDefinition.path) {
        throw new ModelDefinitionValidationError(MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE.MISSING_PATH);
    }
    return true;
};
export const hasValidChannels = (tensor) => tensor.shape.slice(-1)[0] === 3;
export const isNumber = (el) => typeof el === 'number';
export const isValidRange = (range) => Array.isArray(range) && range.length === 2 && range.every(isNumber);
