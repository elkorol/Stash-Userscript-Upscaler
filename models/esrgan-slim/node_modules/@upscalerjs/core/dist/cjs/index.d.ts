import * as tf from '@tensorflow/tfjs-core';
import type * as tfBrowser from '@tensorflow/tfjs';
import type * as tfNode from '@tensorflow/tfjs-node';
import type * as tfNodeGpu from '@tensorflow/tfjs-node-gpu';
import { Tensor, Tensor4D } from '@tensorflow/tfjs-core';
export declare type TF = typeof tfBrowser | typeof tfNode | typeof tfNodeGpu;
export declare type OpExecutor = tfBrowser.OpExecutor | tfNode.OpExecutor | tfNodeGpu.OpExecutor;
export declare type ProcessFn<T extends Tensor> = (t: T) => T;
export interface PackageInformation {
    name: string;
    version: string;
}
export declare type Range = [number, number];
declare type MetaValue = string | number | Meta | null | undefined | boolean;
export declare type Meta = {
    [key: string]: MetaValue;
};
export declare type ModelType = 'graph' | 'layers';
export declare type PreProcess = ProcessFn<Tensor4D>;
export declare type PostProcess = ProcessFn<Tensor4D>;
export declare type Shape4D = [null | number, number, number, number];
export declare const isShape4D: (shape?: unknown) => shape is Shape4D;
export interface ModelDefinition {
    /**
     * Path to a model.json file.
     */
    path: string;
    /**
     * The type of the model. Can be 'graph' or 'layer'. Defaults to 'layer'
     */
    modelType?: ModelType;
    /**
     * The scale of the model. For super resolution models, should match the scale at which the model was trained.
     */
    scale?: number;
    /**
     * @hidden
     *
     * Future option for specifying the number of channels; will enable grayscale and alpha transparency models. Current models only support 3 channels.
     */
    channels?: 3;
    /**
     * @hidden
     *
     * Used internally by UpscalerJS models to encode information about package version and name.
     */
    packageInformation?: PackageInformation;
    /**
     * A function that processes the input image before feeding to the model. For example, you can use this function if you need to regularize your input.
     */
    preprocess?: PreProcess;
    /**
     * A function that processes the input image after being run through model inference. For example, you may need to convert floats to 0-255 integers.
     */
    postprocess?: PostProcess;
    /**
      * Two numbers denoting the range in which the model expects number to be in the range of. Defaults to [0, 255].
      */
    inputRange?: Range;
    /**
     * Two numbers denoting the range in which the model is expected to output its predictions. Numbers can still fall outside of this range, but
     * UpscalerJS will use the range to clip the values appropriately. Defaults to [0, 255].
     */
    outputRange?: Range;
    /**
     * @hidden
     */
    meta?: Meta;
}
export declare type ModelDefinitionFn = (tf: TF) => ModelDefinition;
export declare type ModelDefinitionObjectOrFn = ModelDefinitionFn | ModelDefinition;
export declare type IsTensor<T extends tf.Tensor> = (pixels: Tensor) => pixels is T;
export declare function makeIsNDimensionalTensor<T extends Tensor>(rank: number): IsTensor<T>;
export declare const isFourDimensionalTensor: IsTensor<tf.Tensor4D>;
export declare const isThreeDimensionalTensor: IsTensor<tf.Tensor3D>;
export declare const isTensor: (input: unknown) => input is tf.Tensor<tf.Rank>;
export declare const isString: (el: unknown) => el is string;
export declare const isValidModelType: (modelType: unknown) => modelType is ModelType;
export declare enum MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE {
    UNDEFINED = "undefined",
    INVALID_MODEL_TYPE = "invalidModelType",
    MISSING_PATH = "missingPath"
}
export declare class ModelDefinitionValidationError extends Error {
    type: MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE;
    constructor(type: MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE);
}
export declare const isValidModelDefinition: (modelDefinition?: ModelDefinition) => modelDefinition is ModelDefinition;
export declare const hasValidChannels: (tensor: tf.Tensor) => boolean;
export declare const isNumber: (el: unknown) => el is number;
export declare const isValidRange: (range: unknown) => range is Range;
export {};
//# sourceMappingURL=index.d.ts.map